// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file envelope.proto

import Foundation
import ProtocolBuffers


public struct Events { }

public func == (lhs: Events.Envelope, rhs: Events.Envelope) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOrigin == rhs.hasOrigin) && (!lhs.hasOrigin || lhs.origin == rhs.origin)
  fieldCheck = fieldCheck && (lhs.hasEventType == rhs.hasEventType) && (!lhs.hasEventType || lhs.eventType == rhs.eventType)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasHttpStartStop == rhs.hasHttpStartStop) && (!lhs.hasHttpStartStop || lhs.httpStartStop == rhs.httpStartStop)
  fieldCheck = fieldCheck && (lhs.hasLogMessage == rhs.hasLogMessage) && (!lhs.hasLogMessage || lhs.logMessage == rhs.logMessage)
  fieldCheck = fieldCheck && (lhs.hasValueMetric == rhs.hasValueMetric) && (!lhs.hasValueMetric || lhs.valueMetric == rhs.valueMetric)
  fieldCheck = fieldCheck && (lhs.hasCounterEvent == rhs.hasCounterEvent) && (!lhs.hasCounterEvent || lhs.counterEvent == rhs.counterEvent)
  fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
  fieldCheck = fieldCheck && (lhs.hasContainerMetric == rhs.hasContainerMetric) && (!lhs.hasContainerMetric || lhs.containerMetric == rhs.containerMetric)
  fieldCheck = fieldCheck && (lhs.hasDeployment == rhs.hasDeployment) && (!lhs.hasDeployment || lhs.deployment == rhs.deployment)
  fieldCheck = fieldCheck && (lhs.hasJob == rhs.hasJob) && (!lhs.hasJob || lhs.job == rhs.job)
  fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
  fieldCheck = fieldCheck && (lhs.hasIp == rhs.hasIp) && (!lhs.hasIp || lhs.ip == rhs.ip)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Events {
  public struct EnvelopeRoot {
    public static var sharedInstance : EnvelopeRoot {
     struct Static {
         static let instance : EnvelopeRoot = EnvelopeRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
      Events.HttpRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Events.LogRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Events.MetricRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Events.ErrorRoot.sharedInstance.registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  /// Envelope wraps an Event and adds metadata.
  final public class Envelope : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      /// Type of the wrapped event.
      public enum EventType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        // Removed Heartbeat at position 1
        // Removed HttpStart at position 2
        // Removed HttpStop at position 3
        case HttpStartStop = 4
        case LogMessage = 5
        case ValueMetric = 6
        case CounterEvent = 7
        case Error = 8
        case ContainerMetric = 9

        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .HttpStartStop: return ".HttpStartStop"
                case .LogMessage: return ".LogMessage"
                case .ValueMetric: return ".ValueMetric"
                case .CounterEvent: return ".CounterEvent"
                case .Error: return ".Error"
                case .ContainerMetric: return ".ContainerMetric"
            }
        }
      }

      //Enum type declaration end 

    /// Unique description of the origin of this event.
    public private(set) var origin:String = ""

    public private(set) var hasOrigin:Bool = false
    public private(set) var eventType:Events.Envelope.EventType = Events.Envelope.EventType.HttpStartStop
    public private(set) var hasEventType:Bool = false
    /// UNIX timestamp (in nanoseconds) event was wrapped in this Envelope.
    public private(set) var timestamp:Int64 = Int64(0)

    public private(set) var hasTimestamp:Bool = false
    /// Deployment name (used to uniquely identify source).
    public private(set) var deployment:String = ""

    public private(set) var hasDeployment:Bool = false
    /// Job name (used to uniquely identify source).
    public private(set) var job:String = ""

    public private(set) var hasJob:Bool = false
    /// Index of job (used to uniquely identify source).
    public private(set) var index:String = ""

    public private(set) var hasIndex:Bool = false
    /// IP address (used to uniquely identify source).
    public private(set) var ip:String = ""

    public private(set) var hasIp:Bool = false
    public private(set) var httpStartStop:Events.HttpStartStop!
    public private(set) var hasHttpStartStop:Bool = false
    public private(set) var logMessage:Events.LogMessage!
    public private(set) var hasLogMessage:Bool = false
    public private(set) var valueMetric:Events.ValueMetric!
    public private(set) var hasValueMetric:Bool = false
    public private(set) var counterEvent:Events.CounterEvent!
    public private(set) var hasCounterEvent:Bool = false
    public private(set) var error:Events.Error!
    public private(set) var hasError:Bool = false
    public private(set) var containerMetric:Events.ContainerMetric!
    public private(set) var hasContainerMetric:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !hasOrigin {
        return false
      }
      if !hasEventType {
        return false
      }
      if hasHttpStartStop {
       if !httpStartStop.isInitialized() {
         return false
       }
      }
      if hasLogMessage {
       if !logMessage.isInitialized() {
         return false
       }
      }
      if hasValueMetric {
       if !valueMetric.isInitialized() {
         return false
       }
      }
      if hasCounterEvent {
       if !counterEvent.isInitialized() {
         return false
       }
      }
      if hasError {
       if !error.isInitialized() {
         return false
       }
      }
      if hasContainerMetric {
       if !containerMetric.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasOrigin {
        try output.writeString(1, value:origin)
      }
      if hasEventType {
        try output.writeEnum(2, value:eventType.rawValue)
      }
      if hasTimestamp {
        try output.writeInt64(6, value:timestamp)
      }
      if hasHttpStartStop {
        try output.writeMessage(7, value:httpStartStop)
      }
      if hasLogMessage {
        try output.writeMessage(8, value:logMessage)
      }
      if hasValueMetric {
        try output.writeMessage(9, value:valueMetric)
      }
      if hasCounterEvent {
        try output.writeMessage(10, value:counterEvent)
      }
      if hasError {
        try output.writeMessage(11, value:error)
      }
      if hasContainerMetric {
        try output.writeMessage(12, value:containerMetric)
      }
      if hasDeployment {
        try output.writeString(13, value:deployment)
      }
      if hasJob {
        try output.writeString(14, value:job)
      }
      if hasIndex {
        try output.writeString(15, value:index)
      }
      if hasIp {
        try output.writeString(16, value:ip)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasOrigin {
        serialize_size += origin.computeStringSize(1)
      }
      if (hasEventType) {
        serialize_size += eventType.rawValue.computeEnumSize(2)
      }
      if hasTimestamp {
        serialize_size += timestamp.computeInt64Size(6)
      }
      if hasHttpStartStop {
          if let varSizehttpStartStop = httpStartStop?.computeMessageSize(7) {
              serialize_size += varSizehttpStartStop
          }
      }
      if hasLogMessage {
          if let varSizelogMessage = logMessage?.computeMessageSize(8) {
              serialize_size += varSizelogMessage
          }
      }
      if hasValueMetric {
          if let varSizevalueMetric = valueMetric?.computeMessageSize(9) {
              serialize_size += varSizevalueMetric
          }
      }
      if hasCounterEvent {
          if let varSizecounterEvent = counterEvent?.computeMessageSize(10) {
              serialize_size += varSizecounterEvent
          }
      }
      if hasError {
          if let varSizeerror = error?.computeMessageSize(11) {
              serialize_size += varSizeerror
          }
      }
      if hasContainerMetric {
          if let varSizecontainerMetric = containerMetric?.computeMessageSize(12) {
              serialize_size += varSizecontainerMetric
          }
      }
      if hasDeployment {
        serialize_size += deployment.computeStringSize(13)
      }
      if hasJob {
        serialize_size += job.computeStringSize(14)
      }
      if hasIndex {
        serialize_size += index.computeStringSize(15)
      }
      if hasIp {
        serialize_size += ip.computeStringSize(16)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Events.Envelope> {
      var mergedArray = Array<Events.Envelope>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Events.Envelope? {
      return try Events.Envelope.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Events.Envelope {
      return try Events.Envelope.Builder().mergeFromData(data, extensionRegistry:Events.EnvelopeRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope {
      return try Events.Envelope.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Events.Envelope {
      return try Events.Envelope.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope {
      return try Events.Envelope.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Events.Envelope {
      return try Events.Envelope.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope {
      return try Events.Envelope.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Events.Envelope.Builder {
      return Events.Envelope.classBuilder() as! Events.Envelope.Builder
    }
    public func getBuilder() -> Events.Envelope.Builder {
      return classBuilder() as! Events.Envelope.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Events.Envelope.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Events.Envelope.Builder()
    }
    public func toBuilder() throws -> Events.Envelope.Builder {
      return try Events.Envelope.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Events.Envelope) throws -> Events.Envelope.Builder {
      return try Events.Envelope.Builder().mergeFrom(prototype)
    }
    override public func getDescription(indent:String) throws -> String {
      var output:String = ""
      if hasOrigin {
        output += "\(indent) origin: \(origin) \n"
      }
      if (hasEventType) {
        output += "\(indent) eventType: \(eventType.description)\n"
      }
      if hasTimestamp {
        output += "\(indent) timestamp: \(timestamp) \n"
      }
      if hasHttpStartStop {
        output += "\(indent) httpStartStop {\n"
        if let outDescHttpStartStop = httpStartStop {
          output += try outDescHttpStartStop.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasLogMessage {
        output += "\(indent) logMessage {\n"
        if let outDescLogMessage = logMessage {
          output += try outDescLogMessage.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasValueMetric {
        output += "\(indent) valueMetric {\n"
        if let outDescValueMetric = valueMetric {
          output += try outDescValueMetric.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCounterEvent {
        output += "\(indent) counterEvent {\n"
        if let outDescCounterEvent = counterEvent {
          output += try outDescCounterEvent.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasError {
        output += "\(indent) error {\n"
        if let outDescError = error {
          output += try outDescError.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasContainerMetric {
        output += "\(indent) containerMetric {\n"
        if let outDescContainerMetric = containerMetric {
          output += try outDescContainerMetric.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasDeployment {
        output += "\(indent) deployment: \(deployment) \n"
      }
      if hasJob {
        output += "\(indent) job: \(job) \n"
      }
      if hasIndex {
        output += "\(indent) index: \(index) \n"
      }
      if hasIp {
        output += "\(indent) ip: \(ip) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasOrigin {
               hashCode = (hashCode &* 31) &+ origin.hashValue
            }
            if hasEventType {
               hashCode = (hashCode &* 31) &+ Int(eventType.rawValue)
            }
            if hasTimestamp {
               hashCode = (hashCode &* 31) &+ timestamp.hashValue
            }
            if hasHttpStartStop {
                if let hashValuehttpStartStop = httpStartStop?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuehttpStartStop
                }
            }
            if hasLogMessage {
                if let hashValuelogMessage = logMessage?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuelogMessage
                }
            }
            if hasValueMetric {
                if let hashValuevalueMetric = valueMetric?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevalueMetric
                }
            }
            if hasCounterEvent {
                if let hashValuecounterEvent = counterEvent?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecounterEvent
                }
            }
            if hasError {
                if let hashValueerror = error?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueerror
                }
            }
            if hasContainerMetric {
                if let hashValuecontainerMetric = containerMetric?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontainerMetric
                }
            }
            if hasDeployment {
               hashCode = (hashCode &* 31) &+ deployment.hashValue
            }
            if hasJob {
               hashCode = (hashCode &* 31) &+ job.hashValue
            }
            if hasIndex {
               hashCode = (hashCode &* 31) &+ index.hashValue
            }
            if hasIp {
               hashCode = (hashCode &* 31) &+ ip.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Events.Envelope"
    }
    override public func className() -> String {
        return "Events.Envelope"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Events.Envelope.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Events.Envelope = Events.Envelope()
      public func getMessage() -> Events.Envelope {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasOrigin:Bool {
           get {
                return builderResult.hasOrigin
           }
      }
      public var origin:String {
           get {
                return builderResult.origin
           }
           set (value) {
               builderResult.hasOrigin = true
               builderResult.origin = value
           }
      }
      public func setOrigin(value:String) -> Events.Envelope.Builder {
        self.origin = value
        return self
      }
      public func clearOrigin() -> Events.Envelope.Builder{
           builderResult.hasOrigin = false
           builderResult.origin = ""
           return self
      }
        public var hasEventType:Bool{
            get {
                return builderResult.hasEventType
            }
        }
        public var eventType:Events.Envelope.EventType {
            get {
                return builderResult.eventType
            }
            set (value) {
                builderResult.hasEventType = true
                builderResult.eventType = value
            }
        }
        public func setEventType(value:Events.Envelope.EventType) -> Events.Envelope.Builder {
          self.eventType = value
          return self
        }
        public func clearEventType() -> Events.Envelope.Builder {
           builderResult.hasEventType = false
           builderResult.eventType = .HttpStartStop
           return self
        }
      public var hasTimestamp:Bool {
           get {
                return builderResult.hasTimestamp
           }
      }
      public var timestamp:Int64 {
           get {
                return builderResult.timestamp
           }
           set (value) {
               builderResult.hasTimestamp = true
               builderResult.timestamp = value
           }
      }
      public func setTimestamp(value:Int64) -> Events.Envelope.Builder {
        self.timestamp = value
        return self
      }
      public func clearTimestamp() -> Events.Envelope.Builder{
           builderResult.hasTimestamp = false
           builderResult.timestamp = Int64(0)
           return self
      }
      public var hasDeployment:Bool {
           get {
                return builderResult.hasDeployment
           }
      }
      public var deployment:String {
           get {
                return builderResult.deployment
           }
           set (value) {
               builderResult.hasDeployment = true
               builderResult.deployment = value
           }
      }
      public func setDeployment(value:String) -> Events.Envelope.Builder {
        self.deployment = value
        return self
      }
      public func clearDeployment() -> Events.Envelope.Builder{
           builderResult.hasDeployment = false
           builderResult.deployment = ""
           return self
      }
      public var hasJob:Bool {
           get {
                return builderResult.hasJob
           }
      }
      public var job:String {
           get {
                return builderResult.job
           }
           set (value) {
               builderResult.hasJob = true
               builderResult.job = value
           }
      }
      public func setJob(value:String) -> Events.Envelope.Builder {
        self.job = value
        return self
      }
      public func clearJob() -> Events.Envelope.Builder{
           builderResult.hasJob = false
           builderResult.job = ""
           return self
      }
      public var hasIndex:Bool {
           get {
                return builderResult.hasIndex
           }
      }
      public var index:String {
           get {
                return builderResult.index
           }
           set (value) {
               builderResult.hasIndex = true
               builderResult.index = value
           }
      }
      public func setIndex(value:String) -> Events.Envelope.Builder {
        self.index = value
        return self
      }
      public func clearIndex() -> Events.Envelope.Builder{
           builderResult.hasIndex = false
           builderResult.index = ""
           return self
      }
      public var hasIp:Bool {
           get {
                return builderResult.hasIp
           }
      }
      public var ip:String {
           get {
                return builderResult.ip
           }
           set (value) {
               builderResult.hasIp = true
               builderResult.ip = value
           }
      }
      public func setIp(value:String) -> Events.Envelope.Builder {
        self.ip = value
        return self
      }
      public func clearIp() -> Events.Envelope.Builder{
           builderResult.hasIp = false
           builderResult.ip = ""
           return self
      }
      public var hasHttpStartStop:Bool {
           get {
               return builderResult.hasHttpStartStop
           }
      }
      public var httpStartStop:Events.HttpStartStop! {
           get {
               if httpStartStopBuilder_ != nil {
                  builderResult.httpStartStop = httpStartStopBuilder_.getMessage()
               }
               return builderResult.httpStartStop
           }
           set (value) {
               builderResult.hasHttpStartStop = true
               builderResult.httpStartStop = value
           }
      }
      private var httpStartStopBuilder_:Events.HttpStartStop.Builder! {
           didSet {
              builderResult.hasHttpStartStop = true
           }
      }
      public func getHttpStartStopBuilder() -> Events.HttpStartStop.Builder {
        if httpStartStopBuilder_ == nil {
           httpStartStopBuilder_ = Events.HttpStartStop.Builder()
           builderResult.httpStartStop = httpStartStopBuilder_.getMessage()
           if httpStartStop != nil {
              try! httpStartStopBuilder_.mergeFrom(httpStartStop)
           }
        }
        return httpStartStopBuilder_
      }
      public func setHttpStartStop(value:Events.HttpStartStop!) -> Events.Envelope.Builder {
        self.httpStartStop = value
        return self
      }
      public func mergeHttpStartStop(value:Events.HttpStartStop) throws -> Events.Envelope.Builder {
        if builderResult.hasHttpStartStop {
          builderResult.httpStartStop = try Events.HttpStartStop.builderWithPrototype(builderResult.httpStartStop).mergeFrom(value).buildPartial()
        } else {
          builderResult.httpStartStop = value
        }
        builderResult.hasHttpStartStop = true
        return self
      }
      public func clearHttpStartStop() -> Events.Envelope.Builder {
        httpStartStopBuilder_ = nil
        builderResult.hasHttpStartStop = false
        builderResult.httpStartStop = nil
        return self
      }
      public var hasLogMessage:Bool {
           get {
               return builderResult.hasLogMessage
           }
      }
      public var logMessage:Events.LogMessage! {
           get {
               if logMessageBuilder_ != nil {
                  builderResult.logMessage = logMessageBuilder_.getMessage()
               }
               return builderResult.logMessage
           }
           set (value) {
               builderResult.hasLogMessage = true
               builderResult.logMessage = value
           }
      }
      private var logMessageBuilder_:Events.LogMessage.Builder! {
           didSet {
              builderResult.hasLogMessage = true
           }
      }
      public func getLogMessageBuilder() -> Events.LogMessage.Builder {
        if logMessageBuilder_ == nil {
           logMessageBuilder_ = Events.LogMessage.Builder()
           builderResult.logMessage = logMessageBuilder_.getMessage()
           if logMessage != nil {
              try! logMessageBuilder_.mergeFrom(logMessage)
           }
        }
        return logMessageBuilder_
      }
      public func setLogMessage(value:Events.LogMessage!) -> Events.Envelope.Builder {
        self.logMessage = value
        return self
      }
      public func mergeLogMessage(value:Events.LogMessage) throws -> Events.Envelope.Builder {
        if builderResult.hasLogMessage {
          builderResult.logMessage = try Events.LogMessage.builderWithPrototype(builderResult.logMessage).mergeFrom(value).buildPartial()
        } else {
          builderResult.logMessage = value
        }
        builderResult.hasLogMessage = true
        return self
      }
      public func clearLogMessage() -> Events.Envelope.Builder {
        logMessageBuilder_ = nil
        builderResult.hasLogMessage = false
        builderResult.logMessage = nil
        return self
      }
      public var hasValueMetric:Bool {
           get {
               return builderResult.hasValueMetric
           }
      }
      public var valueMetric:Events.ValueMetric! {
           get {
               if valueMetricBuilder_ != nil {
                  builderResult.valueMetric = valueMetricBuilder_.getMessage()
               }
               return builderResult.valueMetric
           }
           set (value) {
               builderResult.hasValueMetric = true
               builderResult.valueMetric = value
           }
      }
      private var valueMetricBuilder_:Events.ValueMetric.Builder! {
           didSet {
              builderResult.hasValueMetric = true
           }
      }
      public func getValueMetricBuilder() -> Events.ValueMetric.Builder {
        if valueMetricBuilder_ == nil {
           valueMetricBuilder_ = Events.ValueMetric.Builder()
           builderResult.valueMetric = valueMetricBuilder_.getMessage()
           if valueMetric != nil {
              try! valueMetricBuilder_.mergeFrom(valueMetric)
           }
        }
        return valueMetricBuilder_
      }
      public func setValueMetric(value:Events.ValueMetric!) -> Events.Envelope.Builder {
        self.valueMetric = value
        return self
      }
      public func mergeValueMetric(value:Events.ValueMetric) throws -> Events.Envelope.Builder {
        if builderResult.hasValueMetric {
          builderResult.valueMetric = try Events.ValueMetric.builderWithPrototype(builderResult.valueMetric).mergeFrom(value).buildPartial()
        } else {
          builderResult.valueMetric = value
        }
        builderResult.hasValueMetric = true
        return self
      }
      public func clearValueMetric() -> Events.Envelope.Builder {
        valueMetricBuilder_ = nil
        builderResult.hasValueMetric = false
        builderResult.valueMetric = nil
        return self
      }
      public var hasCounterEvent:Bool {
           get {
               return builderResult.hasCounterEvent
           }
      }
      public var counterEvent:Events.CounterEvent! {
           get {
               if counterEventBuilder_ != nil {
                  builderResult.counterEvent = counterEventBuilder_.getMessage()
               }
               return builderResult.counterEvent
           }
           set (value) {
               builderResult.hasCounterEvent = true
               builderResult.counterEvent = value
           }
      }
      private var counterEventBuilder_:Events.CounterEvent.Builder! {
           didSet {
              builderResult.hasCounterEvent = true
           }
      }
      public func getCounterEventBuilder() -> Events.CounterEvent.Builder {
        if counterEventBuilder_ == nil {
           counterEventBuilder_ = Events.CounterEvent.Builder()
           builderResult.counterEvent = counterEventBuilder_.getMessage()
           if counterEvent != nil {
              try! counterEventBuilder_.mergeFrom(counterEvent)
           }
        }
        return counterEventBuilder_
      }
      public func setCounterEvent(value:Events.CounterEvent!) -> Events.Envelope.Builder {
        self.counterEvent = value
        return self
      }
      public func mergeCounterEvent(value:Events.CounterEvent) throws -> Events.Envelope.Builder {
        if builderResult.hasCounterEvent {
          builderResult.counterEvent = try Events.CounterEvent.builderWithPrototype(builderResult.counterEvent).mergeFrom(value).buildPartial()
        } else {
          builderResult.counterEvent = value
        }
        builderResult.hasCounterEvent = true
        return self
      }
      public func clearCounterEvent() -> Events.Envelope.Builder {
        counterEventBuilder_ = nil
        builderResult.hasCounterEvent = false
        builderResult.counterEvent = nil
        return self
      }
      public var hasError:Bool {
           get {
               return builderResult.hasError
           }
      }
      public var error:Events.Error! {
           get {
               if errorBuilder_ != nil {
                  builderResult.error = errorBuilder_.getMessage()
               }
               return builderResult.error
           }
           set (value) {
               builderResult.hasError = true
               builderResult.error = value
           }
      }
      private var errorBuilder_:Events.Error.Builder! {
           didSet {
              builderResult.hasError = true
           }
      }
      public func getErrorBuilder() -> Events.Error.Builder {
        if errorBuilder_ == nil {
           errorBuilder_ = Events.Error.Builder()
           builderResult.error = errorBuilder_.getMessage()
           if error != nil {
              try! errorBuilder_.mergeFrom(error)
           }
        }
        return errorBuilder_
      }
      public func setError(value:Events.Error!) -> Events.Envelope.Builder {
        self.error = value
        return self
      }
      public func mergeError(value:Events.Error) throws -> Events.Envelope.Builder {
        if builderResult.hasError {
          builderResult.error = try Events.Error.builderWithPrototype(builderResult.error).mergeFrom(value).buildPartial()
        } else {
          builderResult.error = value
        }
        builderResult.hasError = true
        return self
      }
      public func clearError() -> Events.Envelope.Builder {
        errorBuilder_ = nil
        builderResult.hasError = false
        builderResult.error = nil
        return self
      }
      public var hasContainerMetric:Bool {
           get {
               return builderResult.hasContainerMetric
           }
      }
      public var containerMetric:Events.ContainerMetric! {
           get {
               if containerMetricBuilder_ != nil {
                  builderResult.containerMetric = containerMetricBuilder_.getMessage()
               }
               return builderResult.containerMetric
           }
           set (value) {
               builderResult.hasContainerMetric = true
               builderResult.containerMetric = value
           }
      }
      private var containerMetricBuilder_:Events.ContainerMetric.Builder! {
           didSet {
              builderResult.hasContainerMetric = true
           }
      }
      public func getContainerMetricBuilder() -> Events.ContainerMetric.Builder {
        if containerMetricBuilder_ == nil {
           containerMetricBuilder_ = Events.ContainerMetric.Builder()
           builderResult.containerMetric = containerMetricBuilder_.getMessage()
           if containerMetric != nil {
              try! containerMetricBuilder_.mergeFrom(containerMetric)
           }
        }
        return containerMetricBuilder_
      }
      public func setContainerMetric(value:Events.ContainerMetric!) -> Events.Envelope.Builder {
        self.containerMetric = value
        return self
      }
      public func mergeContainerMetric(value:Events.ContainerMetric) throws -> Events.Envelope.Builder {
        if builderResult.hasContainerMetric {
          builderResult.containerMetric = try Events.ContainerMetric.builderWithPrototype(builderResult.containerMetric).mergeFrom(value).buildPartial()
        } else {
          builderResult.containerMetric = value
        }
        builderResult.hasContainerMetric = true
        return self
      }
      public func clearContainerMetric() -> Events.Envelope.Builder {
        containerMetricBuilder_ = nil
        builderResult.hasContainerMetric = false
        builderResult.containerMetric = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> Events.Envelope.Builder {
        builderResult = Events.Envelope()
        return self
      }
      public override func clone() throws -> Events.Envelope.Builder {
        return try Events.Envelope.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Events.Envelope {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Events.Envelope {
        let returnMe:Events.Envelope = builderResult
        return returnMe
      }
      public func mergeFrom(other:Events.Envelope) throws -> Events.Envelope.Builder {
        if other == Events.Envelope() {
         return self
        }
        if other.hasOrigin {
             origin = other.origin
        }
        if other.hasEventType {
             eventType = other.eventType
        }
        if other.hasTimestamp {
             timestamp = other.timestamp
        }
        if other.hasDeployment {
             deployment = other.deployment
        }
        if other.hasJob {
             job = other.job
        }
        if other.hasIndex {
             index = other.index
        }
        if other.hasIp {
             ip = other.ip
        }
        if (other.hasHttpStartStop) {
            try mergeHttpStartStop(other.httpStartStop)
        }
        if (other.hasLogMessage) {
            try mergeLogMessage(other.logMessage)
        }
        if (other.hasValueMetric) {
            try mergeValueMetric(other.valueMetric)
        }
        if (other.hasCounterEvent) {
            try mergeCounterEvent(other.counterEvent)
        }
        if (other.hasError) {
            try mergeError(other.error)
        }
        if (other.hasContainerMetric) {
            try mergeContainerMetric(other.containerMetric)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Events.Envelope.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            origin = try input.readString()

          case 16 :
            let valueInteventType = try input.readEnum()
            if let enumseventType = Events.Envelope.EventType(rawValue:valueInteventType){
                 eventType = enumseventType
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueInteventType))
            }

          case 48 :
            timestamp = try input.readInt64()

          case 58 :
            let subBuilder:Events.HttpStartStop.Builder = Events.HttpStartStop.Builder()
            if hasHttpStartStop {
              try subBuilder.mergeFrom(httpStartStop)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            httpStartStop = subBuilder.buildPartial()

          case 66 :
            let subBuilder:Events.LogMessage.Builder = Events.LogMessage.Builder()
            if hasLogMessage {
              try subBuilder.mergeFrom(logMessage)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            logMessage = subBuilder.buildPartial()

          case 74 :
            let subBuilder:Events.ValueMetric.Builder = Events.ValueMetric.Builder()
            if hasValueMetric {
              try subBuilder.mergeFrom(valueMetric)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            valueMetric = subBuilder.buildPartial()

          case 82 :
            let subBuilder:Events.CounterEvent.Builder = Events.CounterEvent.Builder()
            if hasCounterEvent {
              try subBuilder.mergeFrom(counterEvent)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            counterEvent = subBuilder.buildPartial()

          case 90 :
            let subBuilder:Events.Error.Builder = Events.Error.Builder()
            if hasError {
              try subBuilder.mergeFrom(error)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            error = subBuilder.buildPartial()

          case 98 :
            let subBuilder:Events.ContainerMetric.Builder = Events.ContainerMetric.Builder()
            if hasContainerMetric {
              try subBuilder.mergeFrom(containerMetric)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            containerMetric = subBuilder.buildPartial()

          case 106 :
            deployment = try input.readString()

          case 114 :
            job = try input.readString()

          case 122 :
            index = try input.readString()

          case 130 :
            ip = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
